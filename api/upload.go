// Package that contains the models of the JSON objects used in the requests and responses and the methods to create
// new objects that describes the API actions, like the Upload or the AtTokenScraper
package api

import (
	"errors"
	"fmt"
	"io"
	"os"
	"regexp"
	"time"

	"github.com/palantir/stacktrace"

	"github.com/simonedegiacomi/gphotosuploader/auth"
)

var (
	RegexUploadedImageURL = regexp.MustCompile("^https:\\/\\/lh3\\.googleusercontent\\.com\\/([\\w-]+)$")
)

// UploadOptions contains the Upload options
type UploadOptions struct {
	// Required field, a stream from which read the image.
	// You need to close the stream when the image is uploaded
	Stream io.Reader

	// Required field, size of the photo
	FileSize int64

	// Name of the photo (optional)
	Name string

	// UNIX timestamp of the photo (optional)
	Timestamp int64

	// Optional album id
	AlbumId string
}

// NewUploadOptionsFromFile creates a new UploadOptions from a file
func NewUploadOptionsFromFile(file *os.File) (*UploadOptions, error) {
	info, err := file.Stat()
	if err != nil {
		return nil, fmt.Errorf("Can't read file information (%v)", err)
	}

	return &UploadOptions{
		Stream:   file,
		FileSize: info.Size(),

		Name:      file.Name(),
		Timestamp: info.ModTime().Unix() * 1000,
	}, nil
}

// Upload represents an upload, generated by an UploadOptions
type Upload struct {
	// Options of the upload
	Options *UploadOptions

	// Credentials to used to send the requests
	Credentials auth.CookieCredentials

	// URL to which send the request with the image (the real upload)
	url string

	// Id of the image got from the response of the request that enables the image
	enabledImageId string

	// ImageID is the id that the image can be accessed with in the future. The URL of the image can be derived from this ID
	ImageID string
}

func (u *Upload) URLString() string {
	return fmt.Sprintf("https://lh3.googleusercontent.com/%s", u.ImageID)
}

// NewUpload creates a new Upload given an UploadOptions and a Credentials implementation. This method return an error if the
// upload options struct it's not usable to create a new upload
func NewUpload(options *UploadOptions, credentials auth.CookieCredentials) (*Upload, error) {
	if options.Stream == nil {
		return nil, errors.New("The stream of the UploadOptions is nil")
	}
	if options.FileSize <= 0 {
		return nil, errors.New("The fileSize of the UploadOptions is <= 0")
	}

	// Fill missing optional fields
	if options.Name == "" {
		options.Name = time.Now().String()
	}
	if options.Timestamp < 0 {
		options.Timestamp = time.Now().Unix()
	}

	return &Upload{
		Options:     options,
		Credentials: credentials,
	}, nil
}

func getImageIDFromURL(URL string) (string, error) {
	matches := RegexUploadedImageURL.FindStringSubmatch(URL)
	if len(matches) != 2 {
		return "", fmt.Errorf("expected matches to be length 2 (1 submatch only), got %d", len(matches))
	}
	return matches[1], nil
}

// type UploadResult struct {
// 	ImageID string
// }

// func (ur *UploadResult) URLString() string {
// 	return fmt.Sprintf("https://lh3.googleusercontent.com/%s", ur.ImageID)
// }

// Upload tries to upload an image, making multiple http requests
func (u *Upload) Upload() error {
	// First request to get the upload url
	err := u.requestUploadURL()
	if err != nil {
		return errors.New("Can't request an upload url")
	}

	// Upload the real image file
	uploadRes, err := u.uploadFile()
	if err != nil {
		return errors.New("Can't upload file")
	}

	// Enable the photo
	enableRes, err := u.enablePhoto(uploadRes)
	if err != nil {
		return stacktrace.Propagate(err, "can't enable photo")
	}
	uploadedImageURL, err := enableRes.getEnabledImageURL()
	if err != nil {
		return stacktrace.Propagate(err, "can't get enabledImageURL")
	}
	uploadedImageID, err := getImageIDFromURL(uploadedImageURL)
	if err != nil {
		return stacktrace.Propagate(err, "can't get enabledImageID from URL")
	}

	// Add the image to an album if needed
	if u.Options.AlbumId != "" {
		u.moveToAlbum(u.Options.AlbumId)
	}

	u.ImageID = uploadedImageID

	// No errors, image uploaded!
	return nil
}
